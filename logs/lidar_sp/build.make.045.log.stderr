[01m[K/home/jrv/Research/Velodyne/velodyne_ws/src/lidar_sp/src/a3.cpp:[m[K In member function â€˜[01m[Kvoid cloud_filter::cloud_sub_pub(const PointCloud2&)[m[Kâ€™:
[01m[K/home/jrv/Research/Velodyne/velodyne_ws/src/lidar_sp/src/a3.cpp:43:8:[m[K [01;31m[Kerror: [m[Kbase operand of â€˜[01m[K->[m[Kâ€™ has non-pointer type â€˜[01m[Kpcl::PointCloud<pcl::PointXYZRGB>[m[Kâ€™
   cloud->width  = 15;
[01;32m[K        ^[m[K
[01m[K/home/jrv/Research/Velodyne/velodyne_ws/src/lidar_sp/src/a3.cpp:44:8:[m[K [01;31m[Kerror: [m[Kbase operand of â€˜[01m[K->[m[Kâ€™ has non-pointer type â€˜[01m[Kpcl::PointCloud<pcl::PointXYZRGB>[m[Kâ€™
   cloud->height = 1;
[01;32m[K        ^[m[K
[01m[K/home/jrv/Research/Velodyne/velodyne_ws/src/lidar_sp/src/a3.cpp:45:8:[m[K [01;31m[Kerror: [m[Kbase operand of â€˜[01m[K->[m[Kâ€™ has non-pointer type â€˜[01m[Kpcl::PointCloud<pcl::PointXYZRGB>[m[Kâ€™
   cloud->points.resize (cloud->width * cloud->height);
[01;32m[K        ^[m[K
[01m[K/home/jrv/Research/Velodyne/velodyne_ws/src/lidar_sp/src/a3.cpp:45:30:[m[K [01;31m[Kerror: [m[Kbase operand of â€˜[01m[K->[m[Kâ€™ has non-pointer type â€˜[01m[Kpcl::PointCloud<pcl::PointXYZRGB>[m[Kâ€™
   cloud->points.resize (cloud->width * cloud->height);
[01;32m[K                              ^[m[K
[01m[K/home/jrv/Research/Velodyne/velodyne_ws/src/lidar_sp/src/a3.cpp:45:45:[m[K [01;31m[Kerror: [m[Kbase operand of â€˜[01m[K->[m[Kâ€™ has non-pointer type â€˜[01m[Kpcl::PointCloud<pcl::PointXYZRGB>[m[Kâ€™
   cloud->points.resize (cloud->width * cloud->height);
[01;32m[K                                             ^[m[K
[01m[K/home/jrv/Research/Velodyne/velodyne_ws/src/lidar_sp/src/a3.cpp:48:31:[m[K [01;31m[Kerror: [m[Kbase operand of â€˜[01m[K->[m[Kâ€™ has non-pointer type â€˜[01m[Kpcl::PointCloud<pcl::PointXYZRGB>[m[Kâ€™
   for (size_t i = 0; i < cloud->points.size (); ++i)
[01;32m[K                               ^[m[K
[01m[K/home/jrv/Research/Velodyne/velodyne_ws/src/lidar_sp/src/a3.cpp:50:10:[m[K [01;31m[Kerror: [m[Kbase operand of â€˜[01m[K->[m[Kâ€™ has non-pointer type â€˜[01m[Kpcl::PointCloud<pcl::PointXYZRGB>[m[Kâ€™
     cloud->points[i].x = 1024 * rand () / (RAND_MAX + 1.0f);
[01;32m[K          ^[m[K
[01m[K/home/jrv/Research/Velodyne/velodyne_ws/src/lidar_sp/src/a3.cpp:51:10:[m[K [01;31m[Kerror: [m[Kbase operand of â€˜[01m[K->[m[Kâ€™ has non-pointer type â€˜[01m[Kpcl::PointCloud<pcl::PointXYZRGB>[m[Kâ€™
     cloud->points[i].y = 1024 * rand () / (RAND_MAX + 1.0f);
[01;32m[K          ^[m[K
[01m[K/home/jrv/Research/Velodyne/velodyne_ws/src/lidar_sp/src/a3.cpp:52:10:[m[K [01;31m[Kerror: [m[Kbase operand of â€˜[01m[K->[m[Kâ€™ has non-pointer type â€˜[01m[Kpcl::PointCloud<pcl::PointXYZRGB>[m[Kâ€™
     cloud->points[i].z = 1.0;
[01;32m[K          ^[m[K
[01m[K/home/jrv/Research/Velodyne/velodyne_ws/src/lidar_sp/src/a3.cpp:56:8:[m[K [01;31m[Kerror: [m[Kbase operand of â€˜[01m[K->[m[Kâ€™ has non-pointer type â€˜[01m[Kpcl::PointCloud<pcl::PointXYZRGB>[m[Kâ€™
   cloud->points[0].z = 2.0;
[01;32m[K        ^[m[K
[01m[K/home/jrv/Research/Velodyne/velodyne_ws/src/lidar_sp/src/a3.cpp:57:8:[m[K [01;31m[Kerror: [m[Kbase operand of â€˜[01m[K->[m[Kâ€™ has non-pointer type â€˜[01m[Kpcl::PointCloud<pcl::PointXYZRGB>[m[Kâ€™
   cloud->points[3].z = -2.0;
[01;32m[K        ^[m[K
[01m[K/home/jrv/Research/Velodyne/velodyne_ws/src/lidar_sp/src/a3.cpp:58:8:[m[K [01;31m[Kerror: [m[Kbase operand of â€˜[01m[K->[m[Kâ€™ has non-pointer type â€˜[01m[Kpcl::PointCloud<pcl::PointXYZRGB>[m[Kâ€™
   cloud->points[6].z = 4.0;
[01;32m[K        ^[m[K
[01m[K/home/jrv/Research/Velodyne/velodyne_ws/src/lidar_sp/src/a3.cpp:60:45:[m[K [01;31m[Kerror: [m[Kbase operand of â€˜[01m[K->[m[Kâ€™ has non-pointer type â€˜[01m[Kpcl::PointCloud<pcl::PointXYZRGB>[m[Kâ€™
   std::cerr << "Point cloud data: " << cloud->points.size () << " points" << std::endl;
[01;32m[K                                             ^[m[K
[01m[K/home/jrv/Research/Velodyne/velodyne_ws/src/lidar_sp/src/a3.cpp:61:31:[m[K [01;31m[Kerror: [m[Kbase operand of â€˜[01m[K->[m[Kâ€™ has non-pointer type â€˜[01m[Kpcl::PointCloud<pcl::PointXYZRGB>[m[Kâ€™
   for (size_t i = 0; i < cloud->points.size (); ++i)
[01;32m[K                               ^[m[K
[01m[K/home/jrv/Research/Velodyne/velodyne_ws/src/lidar_sp/src/a3.cpp:62:33:[m[K [01;31m[Kerror: [m[Kbase operand of â€˜[01m[K->[m[Kâ€™ has non-pointer type â€˜[01m[Kpcl::PointCloud<pcl::PointXYZRGB>[m[Kâ€™
     std::cerr << "    " << cloud->points[i].x << " "
[01;32m[K                                 ^[m[K
[01m[K/home/jrv/Research/Velodyne/velodyne_ws/src/lidar_sp/src/a3.cpp:63:33:[m[K [01;31m[Kerror: [m[Kbase operand of â€˜[01m[K->[m[Kâ€™ has non-pointer type â€˜[01m[Kpcl::PointCloud<pcl::PointXYZRGB>[m[Kâ€™
                         << cloud->points[i].y << " "
[01;32m[K                                 ^[m[K
[01m[K/home/jrv/Research/Velodyne/velodyne_ws/src/lidar_sp/src/a3.cpp:64:33:[m[K [01;31m[Kerror: [m[Kbase operand of â€˜[01m[K->[m[Kâ€™ has non-pointer type â€˜[01m[Kpcl::PointCloud<pcl::PointXYZRGB>[m[Kâ€™
                         << cloud->points[i].z << std::endl;
[01;32m[K                                 ^[m[K
[01m[K/home/jrv/Research/Velodyne/velodyne_ws/src/lidar_sp/src/a3.cpp:77:27:[m[K [01;31m[Kerror: [m[Kno matching function for call to â€˜[01m[Kpcl::SACSegmentation<pcl::PointXYZ>::setInputCloud(pcl::PointCloud<pcl::PointXYZRGB>&)[m[Kâ€™
   seg.setInputCloud (cloud);
[01;32m[K                           ^[m[K
In file included from [01m[K/usr/include/pcl-1.7/pcl/common/io.h:45:0[m[K,
                 from [01m[K/usr/include/pcl-1.7/pcl/io/file_io.h:42[m[K,
                 from [01m[K/usr/include/pcl-1.7/pcl/io/pcd_io.h:44[m[K,
                 from [01m[K/opt/ros/kinetic/include/pcl_conversions/pcl_conversions.h:70[m[K,
                 from [01m[K/home/jrv/Research/Velodyne/velodyne_ws/src/lidar_sp/src/a3.cpp:3[m[K:
[01m[K/usr/include/pcl-1.7/pcl/pcl_base.h:95:7:[m[K [01;36m[Knote: [m[Kcandidate: void pcl::PCLBase<PointT>::setInputCloud(const PointCloudConstPtr&) [with PointT = pcl::PointXYZ; pcl::PCLBase<PointT>::PointCloudConstPtr = boost::shared_ptr<const pcl::PointCloud<pcl::PointXYZ> >]
       setInputCloud (const PointCloudConstPtr &cloud);
[01;32m[K       ^[m[K
[01m[K/usr/include/pcl-1.7/pcl/pcl_base.h:95:7:[m[K [01;36m[Knote: [m[K  no known conversion for argument 1 from â€˜[01m[Kpcl::PointCloud<pcl::PointXYZRGB>[m[Kâ€™ to â€˜[01m[Kconst PointCloudConstPtr& {aka const boost::shared_ptr<const pcl::PointCloud<pcl::PointXYZ> >&}[m[Kâ€™
[01m[K/home/jrv/Research/Velodyne/velodyne_ws/src/lidar_sp/src/a3.cpp:83:15:[m[K [01;31m[Kerror: [m[Kreturn-statement with a value, in function returning 'void' [-fpermissive]
     return (-1);
[01;32m[K               ^[m[K
[01m[K/home/jrv/Research/Velodyne/velodyne_ws/src/lidar_sp/src/a3.cpp:93:56:[m[K [01;31m[Kerror: [m[Kbase operand of â€˜[01m[K->[m[Kâ€™ has non-pointer type â€˜[01m[Kpcl::PointCloud<pcl::PointXYZRGB>[m[Kâ€™
     std::cerr << inliers->indices[i] << "    " << cloud->points[inliers->indices[i]].x << " "
[01;32m[K                                                        ^[m[K
[01m[K/home/jrv/Research/Velodyne/velodyne_ws/src/lidar_sp/src/a3.cpp:94:56:[m[K [01;31m[Kerror: [m[Kbase operand of â€˜[01m[K->[m[Kâ€™ has non-pointer type â€˜[01m[Kpcl::PointCloud<pcl::PointXYZRGB>[m[Kâ€™
                                                << cloud->points[inliers->indices[i]].y << " "
[01;32m[K                                                        ^[m[K
[01m[K/home/jrv/Research/Velodyne/velodyne_ws/src/lidar_sp/src/a3.cpp:95:56:[m[K [01;31m[Kerror: [m[Kbase operand of â€˜[01m[K->[m[Kâ€™ has non-pointer type â€˜[01m[Kpcl::PointCloud<pcl::PointXYZRGB>[m[Kâ€™
                                                << cloud->points[inliers->indices[i]].z << std::endl;
[01;32m[K                                                        ^[m[K
make[2]: *** [CMakeFiles/a3.dir/src/a3.cpp.o] Error 1
make[1]: *** [CMakeFiles/a3.dir/all] Error 2
make[1]: *** Waiting for unfinished jobs....
make: *** [all] Error 2
